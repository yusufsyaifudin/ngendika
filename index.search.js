var relearn_search_index=[{content:`Getting started
`,description:"",tags:null,title:"Getting Started",uri:"/ngendika/getting-started/index.html"},{content:`Currently, Ngendika only support REST API to interact with the world. Generally, you only need to Create a resource using method POST or PUT method or Send push notification using method POST.
For example, here’s the basic use-case where you want to send a FCM push notification to your Mobile Application:
Create `,description:"",tags:null,title:"Usage",uri:"/ngendika/usage/index.html"},{content:`To install, just download from Github Release Page.
`,description:"",tags:null,title:"Install",uri:"/ngendika/getting-started/install/index.html"},{content:`Here’s full list of config to run the Ngendika server:
# settings for Transport layer transport: http: port: 1234 # dependencies connection # note that key must be alphanumeric only, e.g: db1, postgres1, mysql1 ## define all database connection at once databaseResources: db1: disable: false driver: "postgres" postgres: debug: true dsn: "user=postgres password=postgres host=localhost port=5433 dbname=ngendika sslmode=disable" # Data Source Name cfg1: disable: false driver: config # settings each repository, select based on dependencies connection ## appstore to save application information appService: dbLabel: db1 # refer to databaseResources emailConfigService: dbLabel: db1 # refer to databaseResources fcmService: dbLabel: db1 # refer to databaseResources ## message service will connect to via function call: ## * appService ## * emailConfigService ## * fcmService msgService: dbLabel: db1 # refer to databaseResources maxParallel: 10 # number of semaphore to limit the number of goroutines working on parallel tasks How to read the configuration file First you need to specify all the database connection under databaseResources, it uses key as the label references. For example, you define the databaseResources something like this: databaseResources: db1: disable: false driver: "postgres" postgres: debug: true dsn: "user=postgres password=postgres host=localhost port=5433 dbname=ngendika sslmode=disable" # Data Source Name Then you can use db1 as the label references to the services. Using this approach, we try to separate the Database(s) and Service(s) into separated object. That means, we want to make it easier to move specific data into large resource when needed. For example, in future we may want to drop any unused data in Email config, it should not bother the App database.
In services, such as appService or msgService we can define the database connection by referring it to the database connection label. `,description:"",tags:null,title:"Configuration",uri:"/ngendika/getting-started/configuration/index.html"},{content:`To start sending email you need to follow these steps:
Create the Application Submit your email configuration `,description:"",tags:null,title:"Sending Email",uri:"/ngendika/usage/send-email/index.html"},{content:" ",description:"",tags:null,title:"API Doc",uri:"/ngendika/apidoc/index.html"},{content:"",description:"",tags:null,title:"Categories",uri:"/ngendika/categories/index.html"},{content:`Ngendika is a self-hosted notification server that easy to use.
%%{init:{"theme":"forest"}}%% graph LR; I[Install] --\u003e App[Create App] App --\u003e|Email| EmailCfg[Save Email Config] EmailCfg --\u003e SendEmail[Send Email] App --\u003e|FCM| FCMKey[Save FCM Service Account Key] FCMKey --\u003e SendFCM[Send Push Notification through FCM] App --\u003e|Webhook| Web[Webhook URL] Using Ngendika, you doesn’t need to write or deploy the Push Notification server each time you need it.
Think of it as a Push Notification SaaS but you own your infrastructure!
Ngendika is:
Scalable - Each configuration of an Application (or tenant) is saved in the same table, but we use partitioning to ensure the data is scoped. Getting Started `,description:"",tags:null,title:"Ngendika",uri:"/ngendika/index.html"},{content:"",description:"",tags:null,title:"Tags",uri:"/ngendika/tags/index.html"}]